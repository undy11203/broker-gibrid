# broker-gibrid
Брокер сообщений \
Цели:
1. Гибкие гарантии доставки : возможность переключаться между at-most-once, at-least-once и, если возможно, exactly-once.
2. Поддержка очередей, топиков, групп потребителей .
3. Хранение в памяти или на диске — возможность переключения.
4. Локальный и распределённый режимы .

|Компонент|Язык|
|---|---|
|Ядро брокера (очереди, топики, маршрутизация, хранение, подтверждение сообщений)|C++|
|Сервер (сетевой интерфейс, HTTP/gRPC, TCP/UDP, API, оркестрация узлов)|Go|
|Интерфейс между Go и C++|CGO / Shared library (.so / .dll) / IPC / FFI|

```
mybroker/
├── core/                  # Core на C++
│   ├── queue/             # Очереди
│   ├── topic/             # Топики
│   ├── storage/           # Хранилище (RAM / Disk)
│   ├── consumer_group/    # Группы потребителей
│   └── broker.cpp         # Главная логика
├── api/                   # API на Go
│   ├── server.go          # HTTP/gRPC сервер
│   └── handlers.go        # Обработчики запросов
├── bindings/              # Мост между Go и C++
│   ├── broker_wrapper.go  # CGO или FFI
│   └── libbroker.so       # Скомпилированный C++ код
├── config/
│   └── config.yaml        # Конфиг для режима работы
└── main.go                # Точка входа
```


Подписка:
- pub-sub
- queue
- log

Функционал: доставка с гарантией (at-least-once, exactly-once), задержки, пропускная способность

Протоколы: собственный протокол и (MQTT, AMQP, Kafka-like)

Хранение: in-memory, на диск, распределённое хранение

Масштабируемость: один сервер или кластер

Безопасность: шифрование, аутентификация

# План минимальной реализации брокера сообщений
## 1. Архитектура и компоненты
### Ядро (C++) — отвечает за:

- Приём и отправку сообщений по сети

- Реализацию моделей подписки:

  - Pub/Sub — рассылка сообщения всем подписчикам темы

  - Queue — каждый потребитель получает сообщение один раз (очередь)

  - Log — сообщения сохраняются и могут читаться с оффсета (как в Kafka)

- Гарантии доставки:

  - Минимально at-least-once (соответствующая логика подтверждений)

  - По возможности реализовать exactly-once (например, через идемпотентность)

- Хранение:

  - Быстрый in-memory буфер для сообщений

  - Синхронизация на диск (например, лог сообщений в файл)

- Поддержка минимального собственного бинарного протокола (сообщения, подписка, подтверждения)

- Поддержка шифрования (TLS) на уровне транспортного канала (например, OpenSSL)

### Go-сервис — отвечает за:

- API для клиентов (REST/gRPC)

- Аутентификация и управление правами доступа

- Мониторинг и админские операции

- Связь с ядром (например, через IPC или RPC)

- Поддержка внешних протоколов (MQTT/AMQP-like) на уровне адаптеров

## 2. Минимальный стек и технологии
### C++ ядро:

- Сетевой стек: asio (boost.asio или standalone asio) для асинхронной работы с сетью

- Сериализация протоколов: бинарный формат (например, protobuf или flatbuffers можно позже)

- Файловое хранение: простой write-ahead log, запись сообщений на диск

- TLS: OpenSSL

### Go-сервис:

- HTTP/gRPC сервер

- Аутентификация (JWT, OAuth, или простая Basic Auth)

- API для управления брокером

- Протокол-адаптеры (MQTT, AMQP, Kafka-like) — по мере развития

## 3. Минимальный рабочий прототип ядра (C++)
### Сервер TCP:

- Принимает соединения клиентов

- Обрабатывает базовые команды:

  - SUBSCRIBE topic/type (pubsub/queue/log)

  - PUBLISH topic message

  - ACK message_id (для at-least-once)

- Хранит сообщения в памяти

- Отправляет сообщения подписчикам в соответствии с моделью

- Пишет сообщения в файл журнала (лог)

## 4. Пример работы доставки с гарантией
### At-least-once:

- Клиент подписчик получает сообщение с уникальным ID

- Клиент отправляет ACK обратно

- Если ACK не получен — сообщение отправляется повторно (таймауты и retry)

### Exactly-once (позже):

- Добавить идемпотентность на стороне клиента/сервера

- Хранить состояния доставки и использовать транзакции

## 5. Масштабируемость и кластеризация (позже)
- Минимальная версия — один сервер

Далее можно добавлять:

- Репликацию журнала

- Координация через Raft или Zookeeper

- Балансировщики и шардирование

## 6. Безопасность
- Начать с TLS для транспортного канала

- Простейшая аутентификация (логин/пароль)

- В дальнейшем — интеграция с внешними системами аутентификации и RBAC

## 7. Пошаговый план разработки
- Минимальный TCP-сервер на C++ с поддержкой базовых команд (SUBSCRIBE, PUBLISH, ACK).

- Реализовать pub/sub модель с in-memory очередями.

- Добавить write-ahead лог для устойчивости.

- Добавить обработку at-least-once.

- Сделать простой клиент на Go или даже Python для теста.

- Добавить TLS в ядро.

- Запустить Go-сервис с REST API для управления (список топиков, просмотр подписок).

- Добавить аутентификацию.

- Начать писать адаптеры для MQTT/AMQP.

- Планировать кластеризацию и exactly-once.